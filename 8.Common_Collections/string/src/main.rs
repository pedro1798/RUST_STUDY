use std::iter; 

fn main() {
    // 러스트 언어의 핵심 기능에서는 딱 한 가지 문자열 타입인 문자열 슬라이스 str만을 제공한다.
    // str은 UTF-8로 인코딩되어 다른 어딘가에 저장된 문자열 데이터의 참조자이다.
    // String 타입은 언어의 핵심 기능에 구현x, 러스트의 표준 라이브러리의 커질 수 있고, 가변적이며,
    // 소유권을 갖고 있고, UTF-8로 인코딩된 문자열 타입이다.
    // Vec<T>에서 쓸 수 있는 연산 다수가 String에서도 똑같이 쓸 수 있는데, 이는 String 이 실제로
    // 바이트 벡터에 더하여 몇 가지 보장, 제한, 기능들을 추가한 Wrapper로 구현되어 있기 때문이다.

    let mut s = String::new();
    // 이 라인은 데이터를 담을 수 있는 s라는 빈 문자열을 만들어 준다.
    // 시작 지점에서 저장해 둘 문자열의 초기값을 가질 때는 to_string이라는 메서드를 이용하는데,
    // 이는 Display 트레이트가 구현된 어떤 타입이든 사용 가능하며, 문자열 리터럴도 이 트레이트를
    // 구현하고 있다.
    let data = "initail contents";
    let s = data.to_string(); // str 타입을 String 타입으로 형변환
    let s = "initial contents".to_string(); // 리터럴에도 바로 쓸 수 있음
    
    let s = String::from("initial contents");  // 이렇게도 가능함.
    // 문자열에 다양한 제네릭 API들을 사용할 수 있으며, 이를 통해 다양한 옵션들을 제공할 수 있다.
    // UTF-8의 모든 데이터 스트링에 담을 수 있다.

    let mut s = String::from("foo");
    s.push_str("bar");  // push_str을 이용해 String에 str을 concatenate할 수 있다.
    // push_str 메서드는 문자열 슬라이스를 매개변수로 갖는데, 이는 매개변수의 소유권을 가져올
    // 필요가 없기 때문이다.
    
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);  // push_str은 s2의 소유권을 가져가지 않는다.
    println!("s1 is {s1}");

    let mut s = String::from("lo");
    s.push('l');  // push 메서드는 한 개의 글자를 매개변수로 받아서 String에 추가한다.

    // 가지고 있는 두 개의 문자열을 조합하는 경우:
    let s1 = String::from("Hello, ");
    let s2 = String::from("World!");
    let s3 = s1 + &s2;  // s1은 s3으로 move해서 더 이상 사용할 수 없다.
    // + 연산자를 이용해 String을 concatenation할 수 있다.
    // s1이 더 이상 유효하지 않은 이유와 s2의 참조자가 사용되는 이유는 + 연산자를 사용했을 때
    // 호출되는 함수의 시그니처와 맞춰야 하기 때문이다.
    // + 연산자는 add 매서드를 사용하는데, 이 메서드의 시그니처는 아래처럼 생겼다.
    // fn add(self, s: &str) -> String {}
    // 표준 라이브러리에는 add가 제네릭과 연관 타입을 사용하여 정의되어 있지면 여기선 제네릭에
    // concrete type을 대입하여 보여준다.
    // String에는 &str만 더할 수 있는데 &String인 &s2가 어째서 컴파일 되는가?
    // &s2를 add 호출에 사용할 수 있는 이유는 &String 인수가 &str로 강제될 수 있기 때문이다.
    // add 함수가 호출되면, 러스트는 역참조 강제(deref coercion)을 사용하는데, 이것이 add 함수
    // 내에서 사용되는 &s2를 &s2[..]로 바꾼다.
    // add가 매개변수의 소유권을 가져가지 않으므로 s2는 이후에도 유효한 String이다.
    // 두 번째로, 시그니처에서 add가 self의 소유권을 가져가는 것을 볼 수 있는데, 이는 self가 &를 안
    // 가지고 있기 때문이다. 그러므로 s1이 add에 호출로 이동된 이후에는 더 이상 유효하지 않다.
    // let s3 = s1 + &s2;는 s1의 소유권을 가져다가 s2의 내용물의 복사본을 추가한 다음, 결과물의
    // 소유권을 반환한다.
    // 이 구문은 여러 복사본을 만드는 것처럼 보여도 그렇지 않다.

    // 여러 문자열을 concatenate 하고자 한다면 +의 동작은 불편하다.
    // 그럴 땐 format! 매크로를 이용하면 된다.

    let s1 = String::from("foo");
    let s2 = String::from("bar");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
    // format! 매크로는 println!처럼 작동하지만, 화면에 결과를 출력하는 대신 결과가 담긴 String을
    // 반환해 준다. format!을 이용한 버전이 읽기 쉽고, format! 매크로로 만들어진 코드는 참조자를
    // 이용하므로 이 호출은 아무 매개변수의 소유권도 가져가지 않는다.
    
    // 문자열 내부의 인덱싱:
    // 러스트에선 String을 인덱스로 접근하고자 하면 에러를 얻는다.
    let s1 = String::from("hello");
    // let h = s1[0]; 
    // the type 'String' cannot be indexed by '{integer}' 과 같은 에러를 얻는다.

    // 러스트가 문자열을 메모리에 저장하는 방법:
    // 내부적 표현:
    // String은 Vec<u8>을 감싼 것이다. 
    let hello = String::from("hola");
    // 이 경우 len은 4가 되는데, 이는 문자열을 저장하고 있는 Vec이 4바이트 길이라는 뜻이다.
    // UTF-8로 인코딩되면 각각의 글자들이 1바이트씩 차지한다는 뜻이다.

    let hello = String::from("Здравствуйте");
    println!("문자열의 길이: {}", hello.len());
    // 이 문자열 속 문자 각각의 유니코드 스칼라 값은 저장소의 2바이트를 차지하기 때문에 len은
    // 24이다.
    // 따라서 문자열의 바이트 안의 인덱스는 유효한 유니코드 스칼라 값과 항상 대응되지 않는다.
    // 문자열 속 char마다 크기 다를 수 있어서 인덱싱 못한다는듯..?
    
    // Bytes and Scalar Values and Grapheme Clusters! Oh my!
    // UTF-8에 대한 또 다른 요점은, 실제로는 러스트의 관점에서 문자열을 보는 세 가지 relevant
    // ways가 있단 것이다.: as bytes, scalar values, and grapheme cluster -> (우리가 글자라고 부르는
    // 것과 가장 근접한 것) 이다.
    /*
    데바나가리 (Devanagari) 글자로 쓰인 힌디어 ‘नमस्ते’를 보면, 이것은 궁극적으로 아래와 같은 u8 값들의 Vec으로 저장됩니다:

    [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
    224, 165, 135]
    이건 18바이트이고 컴퓨터가 이 데이터를 궁극적으로 저장하는 방법입니다.
    만일 이를 유니코드 스칼라 값, 즉 러스트의 char 타입인 형태로 본다면, 아래와 같이 보이게 됩니다:

    ['न', 'म', 'स', '्', 'त', 'े']
    여섯 개의 char 값이 있지만, 네 번째와 여섯 번째는 글자가 아닙니다: 
    그 자체로는 이해할 수 없는 발음 구별 부호입니다. 마지막으로, 
    이 문자열을 문자소 클러스터로 본다면, 이 힌디 단어를 구성하는 네 글자를 알아낼 수 있습니다:

    ["न", "म", "स्", "ते"]
    러스트는 컴퓨터가 저장하는 원시 문자열 (raw string) 을 번역하는 다양한 방법을 제공하여
    , 데이터가 담고 있는 것이 무슨 언어든 상관없이 각 프로그램이 
    필요로 하는 통역방식을 선택할 수 있도록 합니다.

    러스트가 String을 인덱스로 접근하여 문자를 얻지 못하도록 하는 마지막 이유는 
    인덱스 연산이 언제나 상수 시간(O(1))에 실행될 것으로 기대받기 때문입니다. 
    그러나 String을 가지고 그러한 성능을 보장하는 것은 불가능한데, 
    그 이유는 러스트가 문자열 내에 유효한 문자가 몇 개 있는지 알아내기 위해 
    내용물을 시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문입니다.
    */

    // 문자열 슬라이싱 하기
    // 문자열 인덱싱의 반환 타입이 어떤것이 (바이트 값인지, 캐릭터인지, 문자소 클러스터인지, 문자열
    // 슬라이스인지) 되어야 하는지 명확하지 않기 때문에 문자열의 인덱싱은 종종 좋지 않은 생각이
    // 된다.
    // 그러므로 문자열 슬라이스를 만들기 위해 정말로 인덱스를 사용하고자 한다면 러스트는 더
    // 구체적인 지정을 요청한다.
    let hello = "Здравствуйте";

    let s = &hello[0..4];
    // 여기서 s는 첫 4 바이트를 담고 있는 &str로, ‘Зд’이 될 것이다.
    // 만약 &hello[0..1] 처럼 문자 바이트의 일부를 슬라이스를 얻으려고 한다면, 러스트는 벡터 내에 
    // 유효하지 않은 인덱스에 접근했을 때와 동일한 방식으로 런타임에 패닉을 발생시킬 것이다.


    // 문자열에 대한 반복을 위한 메서드
    // 문자열 조각에 대한 연산을 하는 가장 좋은 방법은 명시적으로 문자를 원하는 것인지 아니면 
    // 바이트를 웒는 것인지 지정하는 것이다.
    // 개별적인 유니코드 스칼라 값에 대해서는 chars 메서드를 사용하자.

    for c in hello.chars() {
        println!("{c}");
    }

    
    // 다른 방법으로 bytes는 returns each raw bytes, 문제의 도메인이 무엇인가에 따라 적절할 수
    // 있다.


    for b in hello.bytes(){
        println!("{b}");
    }

    // 하지만 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는 것을 기억해야
    // 한다.
    // 데바나가리 문서와 같은 문자열로부터 문자소 클러스터를 얻는 방법은 복잡해서, 이 기능은 표준
    // 라이브러리를 통해 제공되지 않는다. crates.io에 사용 가능한 크레이트가 있다.

    // chars() 와 bytes() 메서드는 문자열의 각 문자에 대한 iterator을 생성한다.
    // iterator은 기본적으로 소유권을 가지고 있다. 따라서 &example.chars()와 같이 참조를 취하려고
    // 하면 반복자의 소유권을 빌릴 수 없어서 컴파일러 에러가 난다.
    // 대신 반복자의 참조를 얻고자 할 때는 iter() 메서드를 사용할 수 있다.

    
    /*
    for c in hello.chars().iter() {  
    // iter()를 사용하여 참조를 얻음. -> chars()는 이미 iterator을 생성하므로 추가적인 호출
    // 필요하지 않다.
        println!("c is: {}", c);
    }
    */



    /*
     Unicode의 개념 중 하나인 "grapheme cluster(글자 클러스터)"는 
     사용자가 인식하는 문자의 기본 단위를 나타냅니다. 
     그래피임 클러스터는 시각적으로 단일 문자로 인식되는 Unicode 코드 포인트의 시퀀스입니다.
     예를 들어, é는 "e"와 악센트 기호(´)로 이루어져 있습니다.
     이때 "é"는 두 개의 코드 포인트로 구성된 그래피임 클러스터입니다.
     Rust에서는 unicode-segmentation 라이브러리를 사용하여 문자열을 
     래피임 클러스터로 분리할 수 있습니다.
    */
    

    // contains 메서드:

    let my_string = String::from("Hello, Rust!");
    
    if my_string.contains("Rust") {
        println!("문자열에 'Rust'가 포함되어 있습니다.");
    } else {
        println!("문자열에 'Rust'가 포함되어 있지 않습니다.");
    }

    // replace 메서드:
    let mut my_string = String::from("Hello, world!");
    let new_string = my_string.replace("world", "Rust");
    println!("원본 문자열: {my_string}");
    println!("대체된 문자열: {new_string}");

}
