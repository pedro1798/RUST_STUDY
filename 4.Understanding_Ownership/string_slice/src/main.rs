fn main() {
    // 스트링 슬라이스는 String의 일부분에 대한 참조자고, 아래와 같이 생겼다.

    let s = String::from("hello world!");

    let hello = %s[0..5];
    let world = &s[6..11];

    let word = first_word(&s);

    s.clear(); // Error! word는 s의 일부를 burrow 중이다.
    println!("the first word is: {word}");

    // 우리가 만일 무언가에 대한 불변 참조자를 만들었을 경우, 가변 참조자를 만들 수 없다.
    // clear 함수가 String을 잘라낼 필요가 있으므로, String의 mutable reference가 필요하므로,
    // 이미 immutable 참조자인 word를 가지고 있으므로 실패하며 컴파일 타임에서 오류를 발생시킨다.

    // 이는 전체 String의 참조자를 갖는 것과 비슷하지만, 추가적으로 [0..5]라는 코드가 붙어 있다.
    // 이는 String에 대한 참조자 보다는, String의 일부분에 대한 참조자이다.
    // start..end 문법은 start부터 시작하여 end를 포함하지 않는 연속된 범위를 기술한다.
    // 내부적으로 슬라이스 데이터 구조는 시작 위치와 슬라이스의 길이를 저장하는데,
    // 이 길이 ㄱ밧은 ending_index에서 starting_index를 뺀 값이다.
    // 따라서 let world = &[6..11];의 경우 world는 s의 6번째 바이트를 가리키고 있는 포인터와 길이값
    // 5를 갖고 있는 슬라이스가 될 것이다.
    // 첫번째, 마지막 인덱스는 생략 가능하다. 즉, &s [0..2]와 &s[..2]는 동일하다.
    

    // 스트링 리터럴은 슬라이스이다.

    let s = "Hello World!";

    // 여기서 s의 타입은 &str이다. 이것은 바이너리의 특정 지점을 가리키고 있는 슬라이스다. 이는 왜
    // 스트링 리터럴이 불변인가도 설명해 준다, &str은 불변 참조자이기 때문이다.
    // s는 문자열 리터럴의 시작 지점을 가리키는 포인터이다. 이 포인터는 문자열의 메모리를
    // 가리키는데, 해당 문자열은 불변한 문자열 슬라이스 (&str)로 표현된다.
    // 실제로는 컴파일된 바이너리에서 문자열이 저장되는 구체적인 위치는 운영체제, 컴파일러, 링커
    // 등에 따라 다를 수 있다. Rust에서는 이러한 세부 사항을 추상화하고, 프로그래머가 직접적으로
    // 이러한 메모리 위치에 접근하거나 그 주소를 알 필요가 없도록 디자인되어 있다.
}

fn first_word(s: &String) -> &str{ 
    // str은 특별한 타입으로, 고정 크기의 문자열이 아닌 문자열 조각에 대한 뷰를 제공한다.
    //  &str은 힙에 저장된 문자열을 참조하는 데 사용된다.
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate(){
        if item == b' '{
            return &s[0..i];
        }
    }
    &s[..]
} 
// 이제 first_word가 호출되면, 해당 데이터와 묶여있는 하나의 값을 반환받게 되었다.
// 이 값은 슬라이스의 요소 개수로 이루어져있다.
