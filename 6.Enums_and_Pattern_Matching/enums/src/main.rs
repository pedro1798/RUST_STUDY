enum IpAddrKind {
    V4,
    V6,
}
enum IpAddr {
    V4(String),
    V6(String),
    // 이렇게 열거형의 각 배리언트에 직접 데이터를 붙임으로써, 구조체를 사용할 필요가 없어졌다. 
    // 또한 여기서 열거형의 동작에 대한 다른 세부 사항을 살펴보기가 쉬워졌다.
}

fn main() {
    // 구조체가 서로 연관된 필드 및 데이터를 묶는 방법을 제공했다면,
    // 열거형은 어떤 값이 여러 개의 가능한 값의 집합 중 하나라는 것을 나타내는 방법을 제공한다.
    // 현재 사용되는 IP 주소 표준은 IPv4, IPv6 두 종류이다. 
    // 앞으로 만들 프로그램에서 다룰 IP 종류는 이 두가지가 전부이므로, 이처럼 가능한 모든
    // variant들을 죽 늘어놓을 수 있는데, 이 때문에 열거형이라는 이름이 붙었다.
    // 열거형의 값은 여러 배리언트 중 하나만 될 수 있다.
    
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
    // 열거형을 정의 할 때의 식별자로 네임스페이스가 만들어져서, 각 배리언트 앞에 이중 콜론을
    // 붙여야 한다.

    route(IpAddrKind::V4); // 이렇게 배리언트 중 하나를 사용해서 함수를 호출할 수 있다.

    let home = IpAddr::V4(String::from("127.0.0.1"));
    // 각 열거형 배리언트의 이름이 해당 열거형 인스턴스의 생성자 함수처럼 된다.
    // IpAddr::V4()는 String 인수를 입력받아서 IpAddr 타입의 인스턴스 결과를 만드는 함수이다.
    // 열거형을 정의한 결과로써 이러한 생성자 함수가 자동적으로 정의된다.

    // 구조체 대신 열거형을 사용하면 또 다른 장점이 있다. 각 배리언트는 다른 타입과 다른 양의
    // 연관된 데이터를 가질 수 있다.
    
    enum IpAddr2 {
        V4(u8, u8, u8, u8),
        V6(String),
    } // 이렇게!
}

fn route(ip_kind: IpAddrKind) {
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}
// IP의 주소를 저장하고 싶다면 이런 방식을 떠올릴 수도 있겠지만, 더 나은 방법이 있다.. IpAddr로!
